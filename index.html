<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Magic Christmas Tree v2</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        #reward-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Bouncy pop-in */
            z-index: 2;
            max-width: 60%;
            max-height: 80%;
            pointer-events: none;
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(255,255,255,0.2);
        }

        #reward-image.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <img id="reward-image" src="image.jpg" alt="Surprise!">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 2500,      // Denser tree
            treeHeight: 60,
            treeRadius: 18,
            explosionForce: 120,       // Faster explosion
            returnSpeed: 0.2,        // Faster return (Higher = Snappier)
            bloomStrength: 0.5,       // How much "Glow"
            bloomRadius: 0.2,
            bloomThreshold: 0,
        };

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 45;
        camera.position.y = 5; // Slightly lower camera to center the tree better

        const renderer = new THREE.WebGLRenderer({ antialias: false }); // Antialias off for post-processing performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- POST PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- SHAPE GENERATORS ---
        function createStarGeometry() {
            const shape = new THREE.Shape();
            const outerRadius = 0.5;
            const innerRadius = 0.25;
            const points = 5;
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();
            return new THREE.ExtrudeGeometry(shape, { depth: 0.2, bevelEnabled: false });
        }

        function createHeartGeometry() {
            const x = 0, y = 0;
            const shape = new THREE.Shape();
            shape.moveTo(x + 0.25, y + 0.25);
            shape.bezierCurveTo(x + 0.25, y + 0.25, x + 0.20, y, x, y);
            shape.bezierCurveTo(x - 0.30, y, x - 0.30, y + 0.35, x - 0.30, y + 0.35);
            shape.bezierCurveTo(x - 0.30, y + 0.55, x - 0.10, y + 0.77, x + 0.25, y + 0.95);
            shape.bezierCurveTo(x + 0.60, y + 0.77, x + 0.80, y + 0.55, x + 0.80, y + 0.35);
            shape.bezierCurveTo(x + 0.80, y + 0.35, x + 0.80, y, x + 0.50, y);
            shape.bezierCurveTo(x + 0.35, y, x + 0.25, y + 0.25, x + 0.25, y + 0.25);
            return new THREE.ExtrudeGeometry(shape, { depth: 0.2, bevelEnabled: false });
        }

        // Cache Geometries
        const geomStar = createStarGeometry();
        const geomHeart = createHeartGeometry();
        const geomBox = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const geomSphere = new THREE.SphereGeometry(0.3, 8, 8);

        // --- CREATE PARTICLES ---
        const particles = [];
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        for (let i = 0; i < CONFIG.particleCount; i++) {
            let mesh;
            const rand = Math.random();

            // Create variety of shapes and colors
            // Note: Emissive property creates the glow when combined with Bloom
            if (rand > 0.90) {
                // Glowing White Stars
                mesh = new THREE.Mesh(geomStar, new THREE.MeshBasicMaterial({ color: 0xffffff }));
                mesh.scale.set(1.5, 1.5, 1.5); // Bigger stars
            } 
            else if (rand > 0.80) {
                // Red Hearts
                mesh = new THREE.Mesh(geomHeart, new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0x550022, roughness: 0.2 }));
                mesh.rotation.z = Math.PI; // Flip heart up
            }
            else if (rand > 0.60) {
                // Presents (Blue/Red/Green)
                const colors = [0xff3333, 0x33ff33, 0x3333ff];
                const c = colors[Math.floor(Math.random() * colors.length)];
                mesh = new THREE.Mesh(geomBox, new THREE.MeshStandardMaterial({ color: c, roughness: 0.5 }));
            }
            else {
                // Snow/Dust (Simple spheres)
                mesh = new THREE.Mesh(geomSphere, new THREE.MeshBasicMaterial({ color: 0xaaccff }));
                mesh.scale.set(0.5, 0.5, 0.5);
            }

            // --- HOLLOW CONE LOGIC ---
            // To make it hollow, we place items mostly on the circumference
            const height = Math.random() * CONFIG.treeHeight;
            const radiusAtHeight = ((CONFIG.treeHeight - height) / CONFIG.treeHeight) * CONFIG.treeRadius;
            
            const theta = Math.random() * Math.PI * 2; // Angle around the tree
            
            // "Hollowness" factor: 
            // 0 = Center, 1 = Edge. We bias random towards 0.8 - 1.0 to keep center empty.
            // Using sqrt(random) pushes distribution outward for creating a shell.
            const r = radiusAtHeight * (0.6 + (Math.random() * 0.4)); 

            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            const y = height - (CONFIG.treeHeight / 2);

            mesh.userData = {
                originalPos: new THREE.Vector3(x, y, z),
                velocity: new THREE.Vector3(0, 0, 0),
                rotSpeed: { x: Math.random()*0.05, y: Math.random()*0.05, z: Math.random()*0.05 }
            };

            mesh.position.set(x, y, z);
            // Rotate shapes randomly so they don't all face the same way
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            
            treeGroup.add(mesh);
            particles.push(mesh);
        }

        // --- MOUSE PARALLAX ---
        const mouse = new THREE.Vector2();
        const targetRotation = new THREE.Vector2();
        
        window.addEventListener('mousemove', (event) => {
            // Normalize mouse position from -1 to 1
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- ANIMATION LOOP ---
        let state = "IDLE";

        function animate() {
            requestAnimationFrame(animate);

            // 1. Mouse Parallax (Smoothly rotate the entire tree group)
            targetRotation.x = mouse.y * 0.2; // Tilt up/down
            targetRotation.y = mouse.x * 0.4; // Rotate left/right
            
            // Smoothly interpolate current rotation to target rotation
            treeGroup.rotation.x += (targetRotation.x - treeGroup.rotation.x) * 0.05;
            treeGroup.rotation.y += (targetRotation.y - treeGroup.rotation.y) * 0.05;

            // 2. Particle Animation
            particles.forEach(p => {
                if (state === "IDLE") {
                    // Gentle float
                    p.position.y += Math.sin(Date.now() * 0.001 + p.position.x) * 0.02;
                    p.rotation.x += p.userData.rotSpeed.x;
                    p.rotation.y += p.userData.rotSpeed.y;
                }
                else if (state === "EXPLODING") {
                    p.position.add(p.userData.velocity);
                    p.rotation.x += 0.1;
                }
                else if (state === "RETURNING") {
                    // Fast snap back using Lerp
                    p.position.lerp(p.userData.originalPos, CONFIG.returnSpeed);
                    p.rotation.x += 0.05;
                }
            });

            composer.render();
        }
        animate();

        // --- INTERACTION ---
        function triggerExplosion() {
            if (state !== "IDLE") return;
            state = "EXPLODING";

            // Calculate explosion vectors
            particles.forEach(p => {
                const dir = p.position.clone().normalize();
                // Add randomness to make it look organic
                const speed = 0.5 + Math.random() * 1.5; 
                p.userData.velocity = dir.multiplyScalar(speed);
            });

            // Timings
            setTimeout(() => { document.getElementById('reward-image').classList.add('visible'); }, 600);
            
            setTimeout(() => {
                document.getElementById('reward-image').classList.remove('visible');
                state = "RETURNING";
                
                setTimeout(() => { state = "IDLE"; }, 2000);
                
            }, 5000); // 5 seconds wait
        }

        window.addEventListener('mousedown', triggerExplosion);
        window.addEventListener('touchstart', triggerExplosion);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>